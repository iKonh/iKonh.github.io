[{"title":"初识Go--iota的用法与枚举","url":"/2018/06/29/初识GO-iota的用法与枚举/","content":"\n其实这篇文章的内容都是我在看常量相关的介绍时总结的，只总结这些是因为其他的比较好理解，而这两点需要实际的代码操作才能理解的原因。\n##iota\n当我们在做一个系统对接时，难免会遇到定义方法返回码的时候。我们需要定义 成功的返回码是多少，失败原因1的返回码是多少，失败原因2的返回码是多少。如果返回码多了，很有可能遇到返回码冲突的情况，造成上游系统的判断bug。<br/>\n\n而在Go中，这个问题就很好解决了，我们可以借助iota来搞定。<br/>\n\niota:Go提供的一个系统常量，数值类型，第一次使用默认为0，每使用一次默认+1。<br/>\n\n有了iota，我们就可以用下列方式来定义返回码：\n\n```golang\nconst (\n\tSUCCESS = iota\n\tFAILED_QUERY\n\tFAILED_INSERT\n\tFAILED_UPDATE\n)\n\nfunc init() {\n\tfmt.Println(SUCCESS, FAILED_QUERY, FAILED_INSERT, FAILED_UPDATE)\n}\n```\n\n输出结果：\n```\n0 1 2 3\n```\n\n关于iota还有几点需要注意下：\n\n1.iota只能用于常量的声明，如果用于变量则会报错\n\n2.iota只有用于同一常量块中，才会有自动+1的操作，否则每次使用都会自动初始化为0<br/>\n例：\n\n```golang\nconst (\n\tSUCCESS = iota\n\tFAILED_QUERY\n\tFAILED_INSERT\n\tFAILED_UPDATE\n)\nconst a = iota\nconst b = iota\n\nfunc init() {\n\tfmt.Println(SUCCESS, FAILED_QUERY, FAILED_INSERT, FAILED_UPDATE, a, b)\n}\n```\n\n输出结果：0 1 2 3 0 0\n\n3.同一常量块中，即使接下来的常量是其他类型的值，也不妨碍iota的计算<br/>\n例:\n\n```golang\nconst (\n\tSUCCESS = iota\n\tFAILED = \"123\"\n\tFAILED_QUERY =iota\n\tFAILED_INSERT\n\tFAILED_UPDATE\n)\n\nfunc init() {\n\tfmt.Println(SUCCESS, FAILED_QUERY, FAILED_INSERT, FAILED_UPDATE)\n}\n```\n结果：0 2 3 4\n\n##枚举\nGo中本身是没有枚举的，需要自定义。定义枚举的时候，就非常需要结合iota\n如下，定义一个星期的枚举：\n\n```golang\ntype WEEK int\n\nconst (\n\tMON WEEK = iota + 1\n\tTUE\n\tWEN\n\tTHE\n\tFRI\n\tSAT\n\tSUN\n)\n\nfunc main() {\n\tvar a = SUN\n\tfmt.Println(reflect.TypeOf(a), a)\n}\n```\n输出结果：main.WEEK 7\n\n由于枚举并不是Go本身的语法，而是自己定义的，所以并不是很严格，例如：\n\n```golang\nconst (\n\tMON WEEK = iota + 1\n\tTUE\n\tWEN\n\tTHE\n\tFRI\n\tSAT\n\tSUN\n)\n\nfunc main() {\n\tvar a = SUN // 此处给a定义为WEEK类型\n\ta = 15 // 此处重新给a赋值15\n\tfmt.Println(reflect.TypeOf(a), a)\n}\n```\n输出结果：main.WEEK 15<br/>\n可见a变量其实还是WEEK类型,因为WEEK类型并不是一个独立类型，而是针对int类型的一个别名，具体可以看一下type的用法，这里不再说明。\n","tags":["Go"]},{"title":"初识Go--init与main方法","url":"/2018/06/27/初识Go-init与main方法/","content":"\n初次接触Go，不用说，肯定要从通过入口方法输出“HelloWord”开始，优先保证环境正常。但是Go得HelloWord并没有那么容易打出来，Go对入口方法做了一些限制，所以就引出了需要对入口方法main以及初始化方法init做一些总结。\n## main方法\nmain方法必须定义在main包中，并且只能有一个，否则无法识别main方法。\n\n## init方法\ninit方法没有包的限制，在一个类中可以同时存在多个init方法。\n\n## init和main的优先级\n这里对于init方法及main方法一些优先级的限制：<br/>\n\n对同一个go文件的init()调用顺序是从上到下的。<br/>\n\n对同一个package中不同文件是按文件名字符串比较“从小到大”顺序调用各文件中的init()函数。<br/>\n\n对于不同的package，如果不相互依赖的话，按照main包中\"先import的后调用\"的顺序调用其包中的init()\n如果package存在依赖，则先调用最早被依赖的package中的init()。<br/>\n\n最后调用main方法。\n\n一个简单的例子如下：\n\n```golang\npackage main\nimport (\n\t\"fmt\"\n)\nfunc main() {\n\tfmt.Print(\"main\")\n}\nfunc init()  {\n\tfmt.Println(\"init1\")\n}\nfunc init() {\n\tfmt.Println(\"init2\")\n}\n```\n\t\n运行后输出结果如下：\n\n```\ninit1\ninit2\nmain\n```","tags":["Go"]},{"title":"text","url":"/2018/06/25/text/"}]